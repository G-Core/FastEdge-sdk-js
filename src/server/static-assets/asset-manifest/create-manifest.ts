import { writeFileSync } from 'node:fs';

import { createManifestFileMap, prettierObjectString } from './create-manifest-file-map.ts';

import type { AssetCacheConfig, StaticAssetManifest } from './types.ts';

import { colorLog } from '~utils/color-log.ts';
import { normalizeConfig } from '~utils/config-helpers.ts';
import { createOutputDirectory, isFile, resolveOsPath } from '~utils/file-system.ts';

/**
 * Creates a Static Asset Manifest file. This is a pre-build step that generates a manifest of all static assets to be included in the build.
 * This `StaticAssetManifest` will be used to create an in memory StaticAssetCache stored in the binary during Wizer processing.
 *
 * @param assetCacheConfig - The configuration for what files to include.
 * @returns An `AssetCache` instance containing the static assets.
 */

async function createStaticAssetsManifest(
  asssetCacheConfig: Partial<AssetCacheConfig>,
): Promise<StaticAssetManifest> {
  const config = normalizeAssetCacheConfig(asssetCacheConfig);

  let outputPath = '/.fastedge/build/static-asset-manifest.js'; // Default output path

  const { assetManifestPath: providedOutputPath } = asssetCacheConfig;
  if (providedOutputPath?.length) {
    const allowNonExistentFile = true;
    let { assetManifestPath: normalizedOutputPath } = config;
    // Ensure that normalizedOutputPath ends with .js/.ts/.cjs/.mjs else add .js
    if (!/\.(js|ts|cjs|mjs)$/u.test(normalizedOutputPath)) {
      colorLog(
        'warning',
        `The provided assetManifestPath '${normalizedOutputPath}' does not end with .js, .ts, .cjs, or .mjs. Adding .js extension.`,
      );
      normalizedOutputPath += '.js';
    }
    // Check if the provided path is a file
    const outputIsAFile = await isFile(normalizedOutputPath, allowNonExistentFile);
    if (!outputIsAFile) {
      colorLog(
        'warning',
        `The provided assetManifestPath '${normalizedOutputPath}' is not a file. Using default path '${outputPath}' instead.`,
      );
    } else {
      outputPath = normalizedOutputPath;
    }
  }

  const manifestBuildOutput = resolveOsPath(`.${outputPath}`);

  await createOutputDirectory(manifestBuildOutput);
  const inlineAssetManifest = await createManifestFileMap(config);

  const readableAssetLines = Object.entries(inlineAssetManifest).map(
    ([key, value]) => `  '${key}': ${prettierObjectString(value)},`,
  );

  const manifestFileContents = [
    '/*',
    ' * DO NOT EDIT THIS FILE - Generated by @gcoredev/FastEdge-sdk-js',
    ' *',
    ' * It will be overwritten on the next build.',
    ' */',
    '',
    'const staticAssetManifest = {',
    ...readableAssetLines,
    '};',
    '',
    'export { staticAssetManifest };',
    '',
  ];

  writeFileSync(manifestBuildOutput, manifestFileContents.join('\n'));

  return inlineAssetManifest;
}

function normalizeAssetCacheConfig(config: Partial<AssetCacheConfig>): AssetCacheConfig {
  return normalizeConfig<AssetCacheConfig>(config, {
    publicDir: 'path',
    assetManifestPath: 'path',
    contentTypes: 'string',
    ignoreDotFiles: 'booleanTruthy',
    ignorePaths: 'pathsArray',
    ignoreWellKnown: 'booleanFalsy',
  });
}

export { createStaticAssetsManifest };
export type { StaticAssetManifest } from './types.ts';
